<!DOCTYPE html><html><head><title>Greg Rosenblatt - Staying sane while writing software</title><meta charset="utf-8" /><meta name="author" content="Greg Rosenblatt" /><meta name="description" content="Personal site of Greg Rosenblatt" /><link rel="stylesheet" href="/main.css" /><link rel="alternate" type="application/atom+xml" title="Greg Rosenblatt's Writing" href="/writing.xml" /><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script><script src="/main.js"></script></head><body><div id="content"><div id="nav-panel"><nav id="nav-main"><ul><li><a href="/./index.html">About</a></li><li><a href="/./writing/index.html">Writing</a></li></ul></nav><nav id="nav-local"><ul></ul></nav></div><div id="content-main"><article><h1 class="content-title">Staying sane while writing software</h1><section><div class="date-range"><span class="date">June 22, 2014</span><span class="date date-end">September 16, 2016</span></div></section><section><p>This is a collection of principles, techniques, and paradigms that lead to useful, quality software while preserving the sanity of the programmers writing it.  Mental health and project success go hand-in-hand.</p><p>Not all of the principles mentioned here can hold in all cases.  Some may conflict in a particular setting.  But where possible, applying these ideas seems to lead to the most satisfying results.</p><p>Currently this is just an outline.</p></section><section><h2>Attributes of desirable software</h2><h3>What most people (should) want</h3><ul><li>features!</li><li>customization</li><li>privacy</li><li>security</li><li>robustness</li><li>performance<ul><li>responsiveness</li><li>low resource consumption</li></ul></li></ul><h3>What programmers also want</h3><ul><li>repeatable behavior</li><li>incremental effects</li><li>local reasoning</li><li>easy rearrangement</li><li>generalization</li><li>efficiency</li><li>scalability</li><li>consistency</li></ul></section><section><h2>Qualities that help satisfy these desires</h2><h3>Relatively abstract</h3><ul><li>monotonicity<ul><li>accumulation described by sets or, more generally, lattices</li></ul></li><li>idempotence</li><li>commutativity<ul><li><a target="_blank" href="https://www.youtube.com/watch?v=JE-jSZ8zToM">The Scalable Commutativity Rule</a><ul><li>"Whenever interface operations commute, they can be implemented in a way that scales."</li></ul></li></ul></li><li>associativity</li><li>orthogonality</li><li>composability</li></ul><h3>Somewhat more concrete</h3><ul><li>principle of least authority</li><li>declarative description</li><li>redundancy</li><li>tolerance</li><li>isolation</li></ul></section><section><h2>Some techniques that can provide these properties</h2><h3>Broad concepts</h3><ul><li>modular design</li><li>decentralized authority<ul><li>distribution of resources, labor and responsibility</li></ul></li><li>granular delegation of authority<ul><li>as in the <a target="_blank" href="https://en.wikipedia.org/wiki/Object-capability_model">object-capability model</a></li></ul></li><li>clear, incorruptible sources of truth</li></ul><h3>More specific architectural choices</h3><ul><li>purely functional cores with imperative shells<ul><li><a target="_blank" href="https://www.destroyallsoftware.com/talks/boundaries">Boundaries</a></li></ul></li><li>shared global state without local state<ul><li><a target="_blank" href="https://awelonblue.wordpress.com/2012/10/21/local-state-is-poison/">Local State is Poison</a></li><li><a target="_blank" href="http://scattered-thoughts.net/blog/2014/02/17/local-state-is-harmful/">Local state is harmful</a></li></ul></li><li><a target="_blank" href="https://en.wikipedia.org/wiki/Object-capability_model">object capabilities</a><ul><li>as in the <a target="_blank" href="http://erights.org">E Programming Language</a></li></ul></li><li>caching</li><li>replication</li><li>append-only databases<ul><li>event sourcing</li><li><a target="_blank" href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">the log as a unifying data abstraction</a></li><li><a target="_blank" href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">Beating the CAP Theorem</a></li></ul></li><li>consistent or rendezvous hashing</li><li>SOA (in the microservices sense)<ul><li>smart endpoints, dumb pipes</li><li><a target="_blank" href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html">service failure resilience</a></li></ul></li><li>REST (in the hypermedia-driven sense)</li><li>CRDTs<ul><li><a target="_blank" href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict-free Replicated Data Types</a></li><li>Strong eventual consistency</li></ul></li><li>LVars<ul><li><a target="_blank" href="https://www.cs.indiana.edu/~lkuper/papers/lvars-fhpc13.pdf">Lattice-based Data Structures</a></li></ul></li><li>CALM<ul><li>Consistency as logical monotonicity</li><li>as in the <a target="_blank" href="http://www.bloom-lang.net/">Bloom programming language</a></li></ul></li><li>Relational Programming<ul><li>Programs that can be run in multiple directions</li><li>as in the <a target="_blank" href="http://minikanren.org/">miniKanren EDSL</a></li></ul></li><li><a target="_blank" href="https://en.wikipedia.org/wiki/Probabilistic_programming_language">Probabilistic Programming</a><ul><li>Programs that describe and perform inference in probabilistic models</li><li>as used in <a target="_blank" href="https://probmods.org/">Probabilistic Models of Cognition</a></li><li><a target="_blank" href="http://probcomp.csail.mit.edu/">The MIT Probabilistic Computing Project</a></li></ul></li></ul></section></article></div></div></body></html>