<!DOCTYPE html><html><head><title>Greg Rosenblatt - Staying sane while writing software</title><meta charset="utf-8" /><meta name="author" content="Greg Rosenblatt" /><meta name="description" content="Personal site of Greg Rosenblatt" /><link rel="stylesheet" href="/main.css" /><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script><script src="/main.js"></script></head><body><div id="content"><div id="nav-panel"><nav id="nav-main"><ul><li><a href="/./index.html">About</a></li><li><a href="/./writing/index.html">Writing</a></li></ul></nav><nav id="nav-local"></nav></div><div id="content-main"><article><h1 class="content-title">Staying sane while writing software</h1><section><div class="date">June 22, 2014</div></section><section><p>This is a collection of principles and techniques that lead to useful, quality software while preserving the sanity of the programmers writing it.  Mental health and project success go hand-in-hand.</p><p>Not all of the principles mentioned here can hold in all cases.  Some may conflict in a particular setting.  But where possible, applying these ideas seems to lead to the most satisfying results.</p><p>Currently this is just an outline.</p></section><section><h2>Attributes of desirable software</h2><h3>What most people (should) want</h3><ul><li>features!</li><li>privacy</li><li>security</li><li>robustness</li><li>performance<ul><li>responsiveness</li><li>low resource consumption</li></ul></li></ul><h3>What programmers also want</h3><ul><li>repeatable behavior</li><li>incremental effects</li><li>local reasoning</li><li>easy rearrangement</li><li>generalization</li><li>customization</li></ul></section><section><h2>Qualities that help satisfy these desires</h2><h3>Relatively abstract</h3><ul><li>idempotence</li><li>monotonicity</li><li>commutativity</li><li>orthogonality</li><li>composability</li></ul><h3>Somewhat more concrete</h3><ul><li>principle of least authority</li><li>redundancy</li><li>tolerance</li><li>isolation</li><li>efficiency</li><li>scalability</li></ul></section><section><h2>Some techniques that can provide these properties</h2><h3>Broad concepts</h3><ul><li>modular design</li><li>decentralized authority<ul><li>distribution of resources, labor and responsibility</li></ul></li><li>granular delegation of authority<ul><li>as in the <a href="https://en.wikipedia.org/wiki/Object-capability_model">object-capability model</a></li></ul></li><li>clear, incorruptible sources of truth</li></ul><h3>More specific architectural choices</h3><ul><li>purely functional cores with imperative shells<ul><li><a href="https://www.destroyallsoftware.com/talks/boundaries">Boundaries</a></li></ul></li><li><a href="https://en.wikipedia.org/wiki/Object-capability_model">object capabilities</a><ul><li><a href="http://erights.org">as in the E Programming Language</a></li></ul></li><li>caching</li><li>replication</li><li>append-only databases<ul><li>event sourcing</li><li><a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">Beating the CAP Theorem</a></li></ul></li><li>consistent or rendezvous hashing</li><li>SOA (in the microservices sense)<ul><li>smart endpoints, dumb pipes</li></ul></li><li>REST (in the hypermedia-driven sense)</li></ul></section></article></div></div></body></html>