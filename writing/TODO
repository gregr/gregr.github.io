domain-specific programming tools
  http://www.evanmiller.org/dont-kill-math.html
  can accept that code is made up of symbols
    this is acknowledged in drawing dyn viz
    whether or not the code is represented as plain text, or in a more diagrammatic way
  having to comprehend the generalizations described by code simply by reading text and simulating the behavior in your mind involves super-human effort and should be unnecessary; comprehension of the concrete is direct and often effortless (exceptions involve data too large for the mind, requiring exploration/navigation; but this is still not an unnatural effort)
    can comprehension of code be made more direct by interactively visualizing the program's transformation as concrete data flows through it? is there a better approach than this?
  output/effect of running code is concrete
  code is currently written directly
  why not instead write code with tools for manipulating the concrete, then generalizing?
    leverage the directness of the concrete medium to know what output you'll be getting with much more certainty
    explicit generalization by indicating/marking important concrete features and their relationships
    tools for implicit generalization might involve machine learning
  are symbols unavoidable when manipulating the abstract?
    you can describe values concretely given enough context
    can you describe actions/operations concretely?
      as machines? but how do you describe these machines without even more context?
        for instance, a specific pixel-based drawing requires only a grid of colored pixels
        to then describe machines that manipulate pixel drawings requires adding even more concepts
          these additional concepts seem to be symbols, reinvented
        even if you don't agree that you need to reinvent symbols to describe machines, once you are dealing with machines you are back where you started:
          the problem of having to simulate their behavior to perform analysis
          it seems the best we can do is provide tools that assist with this simulation?

bash syntax highlighting css
  samp (sample output)
    http://www.w3.org/TR/html5/text-level-semantics.html#the-samp-element
  kbd (keyboard input)
    http://www.w3.org/TR/html5/text-level-semantics.html#the-kbd-element
  var

macro-writing tips; continuation-passing-ish syntax-rules

open recursion in data and functions
  explain how to write fold/eval for such structures
    consider racket (dynamic types)
  mention possibility of using typeclasses
  maybe tie into: tail call optimization is not a red herring (guy steele)

output-event sourcing (decision sourcing)
  vs. input-event sourcing (command sourcing)
  appropriate for online (as in https://en.wikipedia.org/wiki/Online_algorithm), reactive systems
  diagram:
    input-event/request -> decide (state -> input-event -> output-event/decision) -> log decision (example: kafka) -> update (state -> decision -> state) -> commit (write the actual updated state; example: rdbms) -> schedule/trigger downstream processes (send emails? launch missiles?) -> render views -> response
    draw decision and new state flow through pipeline
    point out mostly-pure functions making use of db/state interface
      can still be thought of as pure functions if db:get is an interface to an immutable structure
  scaling:
    data size: external state storage
    parallelism: multiple instances
      consistency and availability trade-offs in design
      instances in lock-step vs. merges of state updates, CRDTs, etc.
      single instance not even necessarily a synchronous pipeline under some trade-offs: delayed feedback of updated state into 'decide'
      crashing/restarting, state rebuilding, time to catch up
